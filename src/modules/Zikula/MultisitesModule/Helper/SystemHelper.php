<?php
/**
 * Multisites.
 *
 * @copyright Albert Pérez Monfort (Zikula)
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @author Albert Pérez Monfort <aperezm@xtec.cat>.
 * @link http://modulestudio.de
 * @link http://zikula.org
 * @version Generated by ModuleStudio 0.7.1 (http://modulestudio.de).
 */

namespace Zikula\MultisitesModule\Helper;

use DateTime;
use DateTimeZone;
use ModUtil;
use PDO;
use PDOException;
use ServiceUtil;
use Symfony\Component\HttpFoundation\Session\Session;
use UserUtil;
use Zikula\Common\Translator\TranslatorInterface;
use Zikula\Common\Translator\TranslatorTrait;
use Zikula\ExtensionsModule\Api\VariableApi;
use Zikula\ExtensionsModule\ExtensionVariablesTrait;
use Zikula\MultisitesModule\Entity\SiteEntity;

/**
 * Utility class for configuration related functionality.
 */
class SystemHelper
{
    use ExtensionVariablesTrait;
    use TranslatorTrait;

    private $dbConfigFile = 'config/multisites_dbconfig.php';

    /**
     * @var Session
     */
    protected $session;

    /**
     * Constructor.
     * Initialises member vars.
     *
     * @param Session             $session      Session service instance
     * @param TranslatorInterface $translator   Translator service instance
     * @param VariableApi         $variableApi  VariableApi service instance
     */
    public function __construct(Session $session, TranslatorInterface $translator, VariableApi $variableApi)
    {
        $this->session = $session;
        $this->setTranslator($translator);
        $this->variableApi = $variableApi;
    }

    /**
     * Sets the translator.
     *
     * @param TranslatorInterface $translator Translator service instance
     */
    public function setTranslator(/*TranslatorInterface */$translator)
    {
        $this->translator = $translator;
    }

    /**
     * Creates initial folders for a new site.
     *
     * @param SiteEntity $site The given site instance
     *
     * @return boolean True on success or false otherwise
     */
    public function createSiteFolders(SiteEntity $site)
    {
        $serviceManager = ServiceUtil::getManager();
        $msConfig = $serviceManager->getParameter('multisites');

        $baseFolder = $msConfig['files_real_path'];
        $siteDirectory = $baseFolder . '/' . $site['siteAlias'];
        $siteFiles = $siteDirectory . $msConfig['site_files_folder'];
        $siteTemp = $siteDirectory . $msConfig['site_temp_files_folder'];

        $directoryList = [
            $baseFolder,
            $siteDirectory,
            $siteDirectory . $msConfig['site_files_folder'],
            $siteTemp,
            $siteTemp . '/error_logs',
            $siteTemp . '/idsTmp',
            $siteTemp . '/purifierCache',
            $siteTemp . '/view_cache',
            $siteTemp . '/view_compiled',
            $siteTemp . '/Theme_cache',
            $siteTemp . '/Theme_compiled',
            $siteTemp . '/Theme_Config'
        ];

        // add additional template folders to the list of directories
        if (!is_null($site['template']) && isset($site['template']['folders'])) {
            foreach ($site['template']['folders'] as $folder) {
                // check for empty value (just for BC)
                if ($folder == '') {
                    continue;
                }
                $directoryList[] = $siteFiles . '/' . trim($folder);
            }
        }

        $flashBag = $this->session->getFlashBag();

        // check and create the directories
        $result = true;
        foreach ($directoryList as $directory) {
            if (!file_exists($directory)) {
                @mkdir($directory, 0777, true);
                if (!file_exists($directory)) {
                    $flashBag->add('error', $this->__f('Error! The <strong>%s</strong> directory does not exist and could not be created automatically. Please create it and make it writeable.', ['%s' => $directory]));

                    $result = false;
                }
            }
            if (file_exists($directory) && !is_writeable($directory)) {
                @chmod($directory, 0777);
                if (!is_writeable($directory)) {
                    $flashBag->add('error', $this->__f('Error! The <strong>%s</strong> directory is not writeable. Please correct that.', ['%s' => $directory]));

                    $result = false;
                }
            }

            if ($result === false) {
                break;
            }
        }


        return $result;
    }

    /**
     * Creates a .htaccess file in the temp folder of a given site.
     *
     * @param SiteEntity $site The given site instance
     *
     * @return boolean True on success or false otherwise
     */
    public function createHtAccessForTempFolder(SiteEntity $site)
    {
        // create a .htaccess file in the temp folder
        $tempAccessFileContent = $this->getVar('tempAccessFileContent', '');
        if ($tempAccessFileContent == '') {
            return true;
        }

        $serviceManager = ServiceUtil::getManager();
        $msConfig = $serviceManager->getParameter('multisites');

        // create .htaccess file
        $siteDirectory = $msConfig['files_real_path'] . '/' . $site['siteAlias'];
        $siteTemp = $siteDirectory . $msConfig['site_temp_files_folder'];

        $file = $siteTemp . '/.htaccess';
        $result = file_put_contents($file, $tempAccessFileContent);

        return ($result !== false);
    }

    /**
     * Connects to an external database.
     *
     * @param array $args Given arguments
     *   string $dbName The database name
     *   string $dbUser The database user name
     *   string $dbPass The database password
     *   string $dbHost The database host name
     *   string $dbType The database type
     *
     * @return mixed Connection object or false on errors
     */
    public function connectToExternalDatabase(array $args)
    {
        /** can be removed probably

            if (!file_exists($this->dbConfigFile)) {
                return false;
            }

            include_once $dbConfigFile;

            // if it is received the parameter "site" it is assumed that the database connection values are in the $databaseArray array
        */

        $dbName = isset($args['dbname']) ? $args['dbname'] : null;
        $dbUser = isset($args['dbuname']) ? $args['dbuname'] : null;
        $dbPass = isset($args['dbpass']) ? $args['dbpass'] : null;
        $dbHost = isset($args['dbhost']) ? $args['dbhost'] : null;
        $dbType = isset($args['dbtype']) ? $args['dbtype'] : null;
        try {
            $connect = new PDO("$dbType:host=$dbHost;dbname=$dbName", $dbUser, $dbPass,
                [PDO::MYSQL_ATTR_INIT_COMMAND => 'SET NAMES utf8']
            );
        } catch (PDOException $e) {
            $this->session->getFlashBag()->add('error', $e->getMessage());

            return false;
        }

        return $connect;
    }

    /**
     * Creates a new database for a new site.
     *
     * @param array $args Given arguments
     *   string $dbName The database name
     *   string $dbUser The database user name
     *   string $dbPass The database password
     *   string $dbHost The database host name
     *   string $dbType The database type
     *
     * @return boolean True on success or false otherwise
     */
    public function createDatabase(array $args)
    {
        $dbName = isset($args['dbname']) ? $args['dbname'] : null;
        $dbType = isset($args['dbtype']) ? $args['dbtype'] : null;

        if (empty($dbName) || empty($dbType)) {
            return false;
        }

        $flashBag = $this->session->getFlashBag();

        // check if database connection works
        $connect = $this->connectToExternalDatabase($args);
        if (!$connect) {
            $flashBag->add('error', $this->__f('Error! Connecting to the database %s failed.', ['%s' => $dbName]));

            return false;
        }

        try {
            $sql = '';
            $sqlStart = 'CREATE DATABASE :dbName ';
            switch ($dbType) {
                case 'mysql':
                case 'mysqli':
                    $sql = $sqlStart . 'DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci';
                    break;
                case 'pgsql':
                    $sql = $sqlStart . 'ENCODING = \'utf8\'';
                    break;
                case 'oci':
                    $sql = $sqlStart . 'national character SET utf8';
                    break;
            }
            if (!empty($sql)) {
                $stmt = $connect->prepare($sql);
                if (!$stmt->execute([':dbName' => $dbName])) {
                    $flashBag->add('error', $this->__('DB Query error.') . ':<br />' . $sql  . "\n");;

                    return false;
                }
            }
        } catch (PDOException $e) {
            $flashBag->add('error', $this->__('Connection error, because:') . ' ' . $e->getMessage());

            return false;
        }

        return true;
    }

    /**
     * Performs all steps required to setup a certain site in a given database.
     *
     * @param SiteEntity $site The currently treated site instance
     *
     * @return boolean True on success or false otherwise
     */
    public function setupDatabaseContent(SiteEntity $site)
    {
        // check if a template is present (could have been decoupled)
        if (!isset($site['template']) || !isset($site['template']['sqlFile']) || empty($site['template']['sqlFile'])) {
            // do nothing then
            return true;
        }

        // read out the existing tables
        $tables = $this->readTables($site);
        if (!is_array($tables)) {
            return false;
        }

        $flashBag = $this->session->getFlashBag();

        // delete old tables (except excluded ones)
        if (!$this->deleteTables($site, $tables['delete'])) {
            $flashBag->add('error', $this->__('Error! Deletion of old database tables failed.'));

            return false;
        }

        // rename/backup excluded tables
        if (!$this->renameExcludedTables($site, $tables['rename'])) {
            $flashBag->add('error', $this->__('Error! Renaming of excluded database tables failed.'));

            return false;
        }

        // recreate the database tables based on the template file
        if (!$this->createTablesFromTemplate($site)) {
            $flashBag->add('error', $this->__('Error! Creation of database tables failed.'));

            return false;
        }

        // rename/restore excluded tables
        if (!$this->renameExcludedTables($site, $tables['rename'], true)) {
            $flashBag->add('error', $this->__('Error! Renaming of excluded database tables failed.'));

            return false;
        }

        // update site parameters like admin name, admin password, cookie name, site name...
        if (!$this->updateConfigValues($site)) {
            $flashBag->add('error', $this->__('Error! Updating the site configuration failed.'));

            return false;
        }

        // handle parameters as modvars
        if (!$this->processParameters($site)) {
            $flashBag->add('error', $this->__('Error! Updating the site parameters failed.'));

            return false;
        }

        return true;
    }

    /**
     * Reads in all tables contained in a database.
     *
     * @param SiteEntity $site The currently treated site instance
     *
     * @return array|boolean Array with table names or false on errors
     */
    protected function readTables(SiteEntity $site)
    {
        $flashBag = $this->session->getFlashBag();

        // check if database connection works
        $connect = $this->connectToExternalDatabase($site->getDatabaseData());
        if (!$connect) {
            $flashBag->add('error', $this->__f('Error! Connecting to the database %s failed.', ['%s' => $site->getDatabaseName()]));

            return false;
        }

        $excludedTables = [];
        if (isset($site['template']) && isset($site['template']['excludedTables']) && is_array($site['template']['excludedTables'])) {
            $excludedTables = $site['template']['excludedTables'];
        }

        $droppedTables = [];
        $backupTables = [];

        try {
            $sql = 'SELECT `table_name` AS `tableName`
                    FROM `information_schema`.`tables`
                    WHERE `table_schema` = :dbName';
            $stmt = $connect->prepare($sql);
            if (!$stmt->execute([':dbName' => $site->getDatabaseName()])) {
                $flashBag->add('error', $this->__('DB Query error.') . ':<br />' . $sql  . "\n");;

                return false;
            }

            $excludedTablesWithWildCards = [];
            $excludeAll = false;
            foreach ($excludedTables as $excludedTable) {
                if ($excludedTable == '*') {
                    $excludeAll = true;
                    break;
                }
                if (strpos($excludedTable, '*') === false) {
                    // no wildcard here
                    continue;
                }
                $excludedTablesWithWildCards[] = $excludedTable;
            }

            while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
                $tableName = $row['tableName'];

                $excluded = false;
                if ($excludeAll === true) {
                    $excluded = true;
                } elseif (in_array($tableName, $excludedTables)) {
                    // table is excluded (e.g. content_content)
                    $excluded = true;
                } else {
                    // check if a wildcard affects $tableName
                    foreach ($excludedTablesWithWildCards as $excludedTable) {
                        $excludedTableParts = explode('*', $excludedTable);
                        $length = strlen($excludedTableParts[0]);
                        if (substr($tableName, 0, $length) === $excludedTableParts[0]) {
                            $excluded = true;
                            break;
                        }
                    }
                }

                if ($excluded === true) {
                    // rename
                    $backupTables[] = $tableName;
                } else {
                    // drop
                    $droppedTables[] = $tableName;
                }
            }
        } catch (PDOException $e) {
            $flashBag->add('error', $this->__('Connection error, because:') . ' ' . $e->getMessage());

            return false;
        }

        return [
            'delete' => $droppedTables,
            'rename' => $backupTables
        ];
    }

    /**
     * Deletes a given list of tables contained in a database.
     *
     * @param SiteEntity $site   The currently treated site instance
     * @param array      $tables List of table names
     *
     * @return boolean True on success or false otherwise
     */
    protected function deleteTables(SiteEntity $site, array $tables)
    {
        if (count($tables) < 1) {
            return true;
        }

        $flashBag = $this->session->getFlashBag();

        // check if database connection works
        $connect = $this->connectToExternalDatabase($site->getDatabaseData());
        if (!$connect) {
            $flashBag->add('error', $this->__f('Error! Connecting to the database %s failed.', ['%s' => $site->getDatabaseName()]));

            return false;
        }

        // drop tables
        $sql = 'DROP TABLE IF EXISTS `' . implode('`, `', $tables) . '`';
        $stmt = $connect->prepare($sql);
        try {
            $stmt->execute();
        } catch (PDOException $e) {
            $flashBag->add('error', $this->__('Connection error, because:') . ' ' . $e->getMessage());

            return false;
        }

        return true;
    }

    /**
     * Renames a given list of tables contained in a database.
     *
     * @param SiteEntity $site    The currently treated site instance
     * @param array      $tables  List of table names
     * @param boolean    $restore False for backup mode and true for recover mode
     *
     * @return boolean True on success or false otherwise
     */
    protected function renameExcludedTables(SiteEntity $site, array $tables, $restore = false)
    {
        if (count($tables) < 1) {
            return true;
        }

        $flashBag = $this->session->getFlashBag();

        // check if database connection works
        $connect = $this->connectToExternalDatabase($site->getDatabaseData());
        if (!$connect) {
            $flashBag->add('error', $this->__f('Error! Connecting to the database %s failed.', ['%s' => $site->getDatabaseName()]));

            return false;
        }

        $backupPrefix = 'zkms_backup_';
        $prefixFrom = '';
        $prefixTo = '';
        if (!$restore) {
            // backup
            $prefixTo = $backupPrefix;
        } else {
            // restore
            $prefixFrom = $backupPrefix;
        }

        try {
            // delete possible destination tables before
            $sql = '';
            foreach ($tables as $tableName) {
                if ($sql != '') {
                    $sql .= ', ';
                }
                $sql .= '`' . $prefixTo . $tableName . '`';
            }
            $sql = 'DROP TABLE IF EXISTS ' . $sql;
            $stmt = $connect->prepare($sql);
            $stmt->execute();

            // rename tables
            if ($site->getDatabaseType() == 'pgsql') {
                // postgres seems to need one command per table
                foreach ($tables as $tableName) {
                    $sql = 'ALTER TABLE `' . $prefixFrom . $tableName . '` RENAME TO `' . $prefixTo . $tableName . '`';
                    $stmt = $connect->prepare($sql);
                    $stmt->execute();
                }
            } else {
                // mysql and oracle can do it in one step
                $sql = '';
                foreach ($tables as $tableName) {
                    if ($sql != '') {
                        $sql .= ', ';
                    }
                    $sql .= '`' . $prefixFrom . $tableName . '` TO `' . $prefixTo . $tableName . '`';
                }
                $sql = 'RENAME TABLE ' . $sql;
                $stmt = $connect->prepare($sql);
                $stmt->execute();
            }
        } catch (PDOException $e) {
            $flashBag->add('error', $this->__('Connection error, because:') . ' ' . $e->getMessage());

            return false;
        }

        return true;
    }

    /**
     * Creates database tables based on a given template file.
     *
     * @param SiteEntity $site The currently treated site instance
     *
     * @return boolean True on success or false otherwise
     */
    protected function createTablesFromTemplate(SiteEntity $site)
    {
        $flashBag = $this->session->getFlashBag();

        // check if the sql exists and it is readable
        $sqlFile = $site['template']['sqlFileFullPath'];
        if (!file_exists($sqlFile) || !is_readable($sqlFile)) {
            $flashBag->add('error', $this->__('Error! The template sql file could not be found.'));

            return false;
        }

        // start reading the file
        $fh = fopen($sqlFile, 'r+');
        if ($fh == false) {
            $flashBag->add('error', $this->__('Error! Opening the template sql file failed.'));

            return false;
        }

        // check if database connection works
        $connect = $this->connectToExternalDatabase($site->getDatabaseData());
        if (!$connect) {
            $flashBag->add('error', $this->__f('Error! Connecting to the database %s failed.', ['%s' => $site->getDatabaseName()]));

            return false;
        }

        // read in the sql file's content
        $lines = file($sqlFile);
        $sql = '';
        $done = false;
        $errorInfo = '';
        foreach ($lines as $line_num => $line) {
            $line = trim($line);
            if (empty($line) || strpos($line, '--') === 0) {
                continue;
            }
            $sql .= $line;
            if (strrpos($line, ';') === strlen($line) - 1) {
                if (!$connect->query($sql)) {
                    $errorInfo = $this->__('Error importing the database in line') . ' ' . $line_num . ':<br />' . $sql . '<br />' . $connect->errorInfo() . "\n";
                    break;
                }

                $done = true;
                $sql = '';
            }
        }

        // close the file
        fclose($fh);

        if (!empty($errorInfo)) {
            $flashBag->add('error', $errorInfo);

            return false;
        }

        if (!$done) {
            $flashBag->add('error', $this->__('Error! Importing the database failed. Perhaps there is a problem with the template file.'));

            return false;
        }

        return true;
    }

    /**
     * Updates the module vars values for a newly created site.
     *
     * @param SiteEntity $site The given site instance
     *
     * @return boolean True on success or false otherwise
     */
    protected function updateConfigValues(SiteEntity $site)
    {
        $flashBag = $this->session->getFlashBag();

        // check if database connection works
        $connect = $this->connectToExternalDatabase($site->getDatabaseData());
        if (!$connect) {
            $flashBag->add('error', $this->__f('Error! Connecting to the database %s failed.', ['%s' => $site->getDatabaseName()]));

            return false;
        }

        // modify the site name
        $sql = 'UPDATE `module_vars`
            SET `value` = :value
            WHERE `modname` = \'ZConfig\'
            AND `name` IN (\'sitename\', \'defaultpagetitle\')';
        $stmt = $connect->prepare($sql);
        if (!$stmt->execute([':value' => serialize($site->getSiteName())])) {
            $flashBag->add('error', $this->__('Error! Setting configurating value failed.') . ':<br />' . $sql  . "\n");

            return false;
        }

        // modify the site description
        $sql = 'UPDATE `module_vars`
            SET `value` = :value
            WHERE `modname` = \'ZConfig\'
            AND `name` IN (\'slogan\', \'defaultmetadescription\')';
        $stmt = $connect->prepare($sql);
        if (!$stmt->execute([':value' => serialize($site->getSiteDescription())])) {
            $flashBag->add('error', $this->__('Error! Setting configurating value failed.') . ':<br />' . $sql  . "\n");

            return false;
        }

        // modify the adminmail
        $sql = 'UPDATE `module_vars`
            SET `value` = :value
            WHERE `modname` = \'ZConfig\'
            AND `name` = \'adminmail\'';
        $stmt = $connect->prepare($sql);
        $adminEmail = $site->getSiteAdminEmail();
        // decode possibly encoded mail addresses (#201)
        if (strpos($adminEmail, '&#') !== false) {
            $adminEmail = html_entity_decode($adminEmail);
        }
        if (!$stmt->execute([':value' => serialize($adminEmail)])) {
            $flashBag->add('error', $this->__('Error! Setting configurating value failed.') . ':<br />' . $sql . "\n");

            return false;
        }

        // modify the session cookie name
        $sql = 'UPDATE `module_vars`
            SET `value` = :value
            WHERE `modname` = \'ZConfig\'
            AND `name` = \'sessionname\'';
        $stmt = $connect->prepare($sql);
        if (!$stmt->execute([':value' => serialize('ZKSID_' . strtoupper($site->getSiteAlias()))])) {
            $flashBag->add('error', $this->__('Error! Setting configurating value failed.') . ':<br />' . $sql . "\n");

            return false;
        }

        // checks if the given administrator user exists
        $stmt = $connect->prepare('SELECT `uname`, `uid`
            FROM `users`
            WHERE `uname` = :uname');
        $stmt->execute([':uname' => $site->getSiteAdminName()]);
        $rs = $stmt->fetch(PDO::FETCH_ASSOC);

        $password = UserUtil::getHashedPassword($site->getSiteAdminPassword());
        if ($rs['uname'] == '') {
            // insert new admin user
            $nowUTC = new DateTime(null, new DateTimeZone('UTC'));
            $nowUTCStr = $nowUTC->format('Y-m-d H:i:s');
            // create administrator
            $sql = 'INSERT INTO users (uname, email, pass, approved_date, user_regdate, activated)
                VALUES (:uname, :email, :password, :approvedDate, :regDate, 1)';
            $stmt = $connect->prepare($sql);
            if (!$stmt->execute([
                ':uname' => $site->getSiteAdminName(),
                ':email' => $site->getSiteAdminEmail(),
                ':password' => $password,
                ':approvedDate' => $nowUTCStr,
                ':regDate' => $nowUTCStr
            ])) {
                $flashBag->add('error', $this->__('Error! Creating the site administrator failed.') . ':<br />' . $sql . "\n");

                return false;
            }

            $stmt = $connect->prepare('SELECT `uid`
                FROM `users`
                WHERE `uname` = :uname');
            $stmt->execute([':uname' => $site->getSiteAdminName()]);
            $rs = $stmt->fetch(PDO::FETCH_ASSOC);
        } else {
            // modify administrator password and email
            $sql = 'UPDATE `users`
                SET `pass` = :password,
                    `email` = :email
                WHERE `uname` = :uname';
            $stmt = $connect->prepare($sql);
            if (!$stmt->execute([':password' => $password, ':email' => $site->getSiteAdminEmail(), ':uname' => $rs['uname']])) {
                $flashBag->add('error', $this->__('Error! Creating the site administrator failed.') . ':<br />' . $sql . "\n");

                return false;
            }
        }
        $uid = $rs['uid'];

        // check if administrator is member of the admin group already
        $adminGroupId = 2;
        $sql = 'SELECT `uid`
            FROM `group_membership`
            WHERE `uid` = :uid
            AND `gid` = :gid';
        $stmt = $connect->prepare($sql);
        $stmt->execute([':uid' => $uid, ':gid' => $adminGroupId]);
        $rs = $stmt->fetch(PDO::FETCH_ASSOC);
        if ($rs['uid'] == '') {
            // add admin to the admin group
            $stmt = $connect->prepare('INSERT INTO `group_membership` (`uid`, `gid`)
                VALUES (:uid, :gid)');
            if (!$stmt->execute([':uid' => $uid, ':gid' => $adminGroupId])) {
                $flashBag->add('error', $this->__('Error! Creating the site administrator failed.') . ':<br />' . $sql . "\n");

                return false;
            }
        }

        return true;
    }

    /**
     * Returns a list of parameter names and values for a certain site.
     *
     * @param SiteEntity $site The given site instance
     *
     * @return array Built list of parameters
     */
    protected function determineParameters(SiteEntity $site)
    {
        $parameters = [];

        if (!is_array($site['template']['parameters']) || count($site['template']['parameters']) < 1) {
            return $parameters;
        }

        // init result array
        foreach ($site['template']['parameters'] as $parameterName) {
            $parameters[$parameterName] = '';
        }

        // read in csv values
        if ($site['parametersCsvFile'] !== null && $site['parametersCsvFile'] != '') {
            $row = 1;
            $csvFilePath = $site['parametersCsvFileFullPath'];
            if (file_exists($csvFilePath) && ($handle = fopen($csvFilePath, 'r')) !== FALSE) {
                $delimiter = ';';
                while (($paramParts = fgetcsv($handle, 1000, $delimiter)) !== FALSE) {
                    if (count($paramParts) != 2) {
                        continue;
                    }

                    if (!in_array($paramParts[0], array_keys($parameters))) {
                        continue;
                    }

                    $parameters[$paramParts[0]] = $paramParts[1];
                }
                fclose($handle);
            }
        }

        // read in manually entered values
        if (is_array($site['parametersArray']) && count($site['parametersArray']) > 0) {
            foreach ($site['parametersArray'] as $siteParam) {
                $paramParts = explode(': ', $siteParam);
                if (count($paramParts) != 2) {
                    continue;
                }

                if (!in_array($paramParts[0], array_keys($parameters))) {
                    continue;
                }

                $parameters[$paramParts[0]] = $paramParts[1];
            }
        }

        return $parameters;
    }

    /**
     * Inserts parameters and parameter values as module vars.
     *
     * @param SiteEntity $site The given site instance
     *
     * @return boolean True on success or false otherwise
     */
    protected function processParameters(SiteEntity $site)
    {
        $flashBag = $this->session->getFlashBag();

        // check if database connection works
        $connect = $this->connectToExternalDatabase($site->getDatabaseData());
        if (!$connect) {
            $flashBag->add('error', $this->__f('Error! Connecting to the database %s failed.', ['%s' => $site->getDatabaseName()]));

            return false;
        }

        $parameterPrefix = 'parameterValue';

        // delete obsolete parameter modvars which could exist due to another (earlier) template
        $sql = 'DELETE FROM `module_vars`
                WHERE `modname` = \'Multisites\'
                AND `name` LIKE \'' . $parameterPrefix . '%\'';
        $stmt = $connect->prepare($sql);
        if (!$stmt->execute()) {
            $flashBag->add('error', $this->__('Error! Deleting old parameters failed.'));

            return false;
        }

        // insert new parameters
        $sql = 'INSERT INTO `module_vars` (`modname`, `name`, `value`)
                VALUES (\'Multisites\', :name, :value)';

        // determine new parameter names and values
        $parameters = $this->determineParameters($site);
        if (count($parameters) > 0) {
            foreach ($parameters as $parameterName => $parameterValue) {
                $stmt = $connect->prepare($sql);
                if (!$stmt->execute([':name' => $parameterPrefix . ucfirst($parameterName), ':value' => serialize($parameterValue)])) {
                    $flashBag->add('error', $this->__f('Error! Creating parameter "%s" failed.', ['%s' => ucfirst($parameterName)]));

                    return false;
                }
            }
        }

        // add logo path as parameter
        $logo = ($site['logo'] !== null && $site['logo'] != '' && file_exists($site['logoFullPath'])) ? $site['logoFullPath'] : '';
        $stmt = $connect->prepare($sql);
        if (!$stmt->execute([':name' => $parameterPrefix . 'Logo', ':value' => serialize($logo)])) {
            $flashBag->add('error', $this->__f('Error! Creating parameter "%s" failed.', ['%s' => 'Logo']));

            return false;
        }

        // add favicon path as parameter
        $favIcon = ($site['favIcon'] !== null && $site['favIcon'] != '' && file_exists($site['favIconFullPath'])) ? $site['favIconFullPath'] : '';
        $stmt = $connect->prepare($sql);
        if (!$stmt->execute([':name' => $parameterPrefix . 'FavIcon', ':value' => serialize($favIcon)])) {
            $flashBag->add('error', $this->__f('Error! Creating parameter "%s" failed.', ['%s' => 'FavIcon']));

            return false;
        }

        return true;
    }

    /**
     * Updates the multisites_dbconfig.php configuration file.
     *
     * @return boolean True on success or false otherwise
     */
    public function updateDatabaseConfigFile()
    {
        if (!file_exists($this->dbConfigFile)) {
            return false;
        }

        // get all active sites
        $where = 'tbl.active = 1';
        $sites = ModUtil::apiFunc('ZikulaMultisitesModule', 'selection', 'getEntities', ['ot' => 'site', 'where' => $where, 'useJoins' => false]);
        if ($sites === false) {
            return false;
        }

        $dbArray = [];
        foreach ($sites as $site) {
            $dbArray[$site->getSiteDns()] = $site->getDatabaseData();
        }

        // write file
        $dbconfig = var_export($dbArray, true);
        $phpCode = "<?php\n\$databaseArray = $dbconfig;";

        if (!file_put_contents($this->dbConfigFile, $phpCode)) {
            return false;
        }

        return true;
    }

    /**
     * Deletes a database.
     *
     * @param array $args Given arguments
     *   string $dbName The database name
     *   string $dbUser The database user name
     *   string $dbPass The database password
     *   string $dbHost The database host name
     *   string $dbType The database type
     *
     * @return Boolean True on success or false otherwise
     */
    public function deleteDatabase($args)
    {
        // check if database connection works
        $connect = $this->connectToExternalDatabase($args);
        if (!$connect) {
            $flashBag = $this->session->getFlashBag();
            $flashBag->add('error', $this->__f('Error! Connecting to the database %s failed.', ['%s' => $args['dbName']]));

            return false;
        }

        // now try to delete the database
        try {
            $stmt = $connect->prepare('DROP DATABASE :dbName;');
            try {
                $stmt->execute([':dbName' => $args['dbName']]);
            } catch (PDOException $e) {
                return false;
            }
        } catch (PDOException $e) {
            return false;
        }

        return true;
    }

    /**
     * Deletes a directory recursively.
     *
     * @param string $dirName Name of the directory to be deleted
     *
     * @return Boolean True on success or false otherwise
     */
    public function deleteDir($dirName)
    {
        if (!file_exists($dirName)) {
            return true;
        }

        $flashBag = $this->session->getFlashBag();

        $dir = dir($dirName);
        while ($file = $dir->read()) {
            if ($file != '.' && $file != '..') {
                if (is_dir($dirName . '/' . $file)) {
                    $this->deleteDir($dirName . '/' . $file);
                    continue;
                }
                if (!@unlink($dirName . '/' . $file)) {
                    $flashBag->add('error', $this->__('Error deleting file:') . ' ' . $dirName . '/' . $file);

                    return false;
                }
            }
        }
        $dir->close();
        if (!@rmdir($dirName)) {
            $flashBag->add('error', $this->__('Error deleting file:') . ' ' . $dirName);

            return false;
        }

        return true;
    }

    /**
     * Checks whether the operating system is Windows.
     *
     * @return boolean True if Windows is detected, false otherwise
     */
    protected function isOnWindows() 
    {
        return (strcasecmp(substr(PHP_OS, 0, 3), 'WIN') == 0);
    }

    /**
     * Returns complete file path to the mysql program.
     *
     * @return string Path to the mysql program
     */
    protected function getMySQLFilePath()
    {
        if ($this->isOnWindows()) {
            if (file_exists('/xampp/mysql/bin/mysql.exe')) return realpath('/xampp/mysql/bin/mysql.exe');   
            if (file_exists('/mysql/bin/mysql.exe')) return realpath('/mysql/bin/mysql.exe'); 
            if (file_exists('/Programme/mysql/bin/mysql.exe')) return realpath('/Programme/mysql/bin/mysql.exe'); 
            if (file_exists('/Programme/xampp/mysql/bin/mysql.exe')) return realpath('/Programme/xampp/mysql/bin/mysql.exe');   
            if (file_exists('/Program Files/mysql/bin/mysql.exe')) return realpath('/Program Files/mysql/bin/mysql.exe'); 
            if (file_exists('/Program Files/xampp/mysql/bin/mysql.exe')) return realpath('/Program Files/xampp/mysql/bin/mysql.exe');   
        } else {
            if (file_exists('/usr/bin/mysql')) return '/usr/bin/mysql'; 
            if (file_exists('/usr/sbin/mysql')) return '/usr/sbin/mysql'; 
            if (file_exists('/usr/etc/mysql')) return '/usr/etc/mysql'; 
            if (file_exists('/etc/mysql')) return '/etc/mysql'; 
            if (file_exists('/usr/ucblib/mysql')) return '/usr/ucblib/mysql'; 
            if (file_exists('/usr/lib/mysql')) return '/usr/lib/mysql'; 
        }

        return null;
    }

    /**
     * Creates a database dump into the given sql file.
     *
     * @param SiteEntity $site           The currently treated site instance
     * @param string     $outputFilePath Path of output file
     *
     * @return boolean True on success or false otherwise
     */
    public function dumpDatabase(SiteEntity $site, $outputFilePath)
    {
        ini_set('max_execution_time', 600);

        $flashBag = $this->session->getFlashBag();

        // find the "mysqldump" program
        $mysqlPath = $this->getMySQLFilePath(); // z.B. c:\Programme\xampp\mysql\bin\mysql.exe
        if (!$mysqlPath) {
            $flashBag->add('error', $this->__('Error! Could not find MySQL program directory.'));

            return false;
        }
        $dumper = dirname($mysqlPath) . ($this->isOnWindows() ? '/mysqldump.exe' : '/mysqldump');
        if (!file_exists($dumper)) {
            $flashBag->add('error', $this->__('Error! The "mysqldump" program is not installed.'));

            return false;
        }

        if (file_exists($outputFilePath)) {
            @unlink($outputFilePath);
        }

        $cmd = $dumper;
        $cmd .= ' --user=' . $site['databaseUserName'];
        $cmd .= ' --password="' . $site['databasePassword'] . '"';
        $cmd .= ' --host=' . $site['databaseHost'] . '';
        $cmd .= ' --quote-names --opt --compress --default-character-set=utf8';
        $cmd .= ' ' . $site['databaseName'];
        $cmd .= ' > ' . $outputFilePath;
        system($cmd, $retval);
        if ($retval != 0) {
            $flashBag->add('error', $this->__f('Error! The database dump failed. Please ensure that the database user %1$s has the "LOCK_TABLES" permission and the web service may write into the %2$s folder.', ['%1$s' => $site['databaseUserName'], '%2$s' => dirname($outputFilePath)]));

            return false;
        }

        return true;
    }

    /**
     * Creates a global administrator for a given site.
     *
     * @param SiteEntity $site The currently treated site instance
     *
     * @return boolean True on success or false otherwise
     */
    public function createAdministrator(SiteEntity $site)
    {
        $flashBag = $this->session->getFlashBag();

        // get global administrator parameters
        $globalAdminName = $this->getVar('globalAdminName');
        $globalAdminPassword = $this->getVar('globalAdminPassword');
        $globalAdminEmail = $this->getVar('globalAdminEmail');
        // check if the global administrator name, password and email had been defined
        if ($globalAdminName == '' || $globalAdminPassword == '' || $globalAdminEmail == '') {
            $flashBag->add('error', $this->__('You have not defined the global administrator name or password. Check the module configuration.'));

            return false;
        }

        // check if database connection works
        $connect = $this->connectToExternalDatabase($site->getDatabaseData());
        if (!$connect) {
            $flashBag->add('error', $this->__f('Error! Connecting to the database %s failed.', ['%s' => $site->getDatabaseName()]));

            return false;
        }

        // check if the super administrator exists
        $sql = 'SELECT `uid`
                FROM `users`
                WHERE `uname`= :globalAdminName';
        $stmt = $connect->prepare($sql);
        $stmt->execute([':globalAdminName' => $globalAdminName]);
        $rs = $stmt->fetch(PDO::FETCH_ASSOC);
        $uid = $rs['uid'];

        // encrypt the password with the hash method
        $password = UserUtil::getHashedPassword($globalAdminPassword);

        if ($uid == '') {
            // the user doesn't exist, thus we create it
            $nowUTC = new DateTime(null, new DateTimeZone('UTC'));
            $nowUTCStr = $nowUTC->format('Y-m-d H:i:s');
            $stmt = $connect->prepare('INSERT INTO users (uname, email, pass, approved_date, user_regdate, activated)
                VALUES (:uname, :email, :password, :approvedDate, :regDate, 1)');
            if (!$stmt->execute([':uname' => $globalAdminName, ':email' => $globalAdminEmail, ':password' => $password, ':approvedDate' => $nowUTCStr, ':regDate' => $nowUTCStr])) {
                $flashBag->add('error', $this->__('Error! Creating global administrator failed.'));

                return false;
            }

            $sql = 'SELECT `uid`
                    FROM `users`
                    WHERE `uname`= :globalAdminName';
            $stmt = $connect->prepare($sql);
            $stmt->execute([':globalAdminName' => $globalAdminName]);
            $rs = $stmt->fetch(PDO::FETCH_ASSOC);
            if (!$rs) {
                $flashBag->add('error', $this->__('Error! Getting global administrator values failed.'));

                return false;
            }
            $uid = $rs['uid'];

            if ($uid != '') {
                // insert the user into the administrators group
                $stmt = $connect->prepare('INSERT INTO group_membership (uid, gid) VALUES (:uid, 2)');
                if (!$stmt->execute([':uid' => $uid])) {
                    $flashBag->add('error', $this->__('Error! Adding global administrator to admin group failed.'));

                    return false;
                }
            }
        } else {
            // check if the user is administrator
            $adminGroupId = 2;
            $sql = 'SELECT `gid`
                    FROM `group_membership`
                    WHERE `uid` = :uid
                    AND gid = :gid';
            $stmt = $connect->prepare($sql);
            $stmt->execute([':uid' => $uid, ':gid' => $adminGroupId]);
            $rs = $stmt->fetch(PDO::FETCH_ASSOC);
            if (!$rs) {
                $flashBag->add('error', $this->__('Error! Getting global administrator group failed.'));

                return false;
            }
            $gid = $rs['gid'];

            if ($gid == '') {
                // the user is not administrator, hence we insert the user into the administrators group
                $stmt = $connect->prepare('INSERT INTO `group_membership` (`uid`, `gid`) VALUES (:uid, :gid)');
                if (!$stmt->execute([':uid' => $uid, ':gid' => $adminGroupId])) {
                    $flashBag->add('error', $this->__('Error! Adding global administrator to admin group failed.'));

                    return false;
                }
            }

            // update global administrator password
            $sql = 'UPDATE `users`
                    SET `pass` = :password
                    WHERE `uid` = :uid';
            $stmt = $connect->prepare($sql);
            if (!$stmt->execute([':uid' => $uid, ':password' => $password])) {
               $flashBag->add('error', $this->__('Error! Updating global administrator password failed.'));

               return false;
            }
        }

        return true;
    }

    /**
     * Recover the first row in the permissions table for administrators.
     *
     * @param SiteEntity $site The currently treated site instance
     *
     * @return boolean True on success or false otherwise
     */
    public function recoverAdminSiteControl(SiteEntity $site)
    {
        $flashBag = $this->session->getFlashBag();

        // check if database connection works
        $connect = $this->connectToExternalDatabase($site->getDatabaseData());
        if (!$connect) {
            $flashBag->add('error', $this->__f('Error! Connecting to the database %s failed.', ['%s' => $site->getDatabaseName()]));

            return false;
        }

        // delete the sequence in the first position
        $sql = 'DELETE FROM `group_perms`
                WHERE `sequence` < 1
                OR `pid` = 1';
        $stmt = $connect->prepare($sql);
        if (!$stmt->execute()) {
            $flashBag->add('error', $this->__('Error! Deleting the permission sequences having a value below 0 failed.'));

            return false;
        }

        // insert a new sequence
        $sql = 'INSERT INTO `group_perms` (`gid`, `sequence`, `component`, `instance`, `level`, `pid`)
                VALUES (2, 0, \'.*\', \'.*\', 800, 1)';
        $stmt = $connect->prepare($sql);
        if (!$stmt->execute()) {
            $flashBag->add('error', $this->__('Error! Creating the new permission sequence failed.'));

            return false;
        }

        return true;
    }
}
