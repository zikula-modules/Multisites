<?php
/**
 * Multisites.
 *
 * @copyright Albert Pérez Monfort (Zikula)
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @package Multisites
 * @author Albert Pérez Monfort <aperezm@xtec.cat>.
 * @link http://modulestudio.de
 * @link http://zikula.org
 * @version Generated by ModuleStudio 0.7.0 (http://modulestudio.de).
 */

/**
 * Ajax controller class providing navigation and interaction functionality.
 */
class Multisites_Controller_Ajax extends Multisites_Controller_Base_Ajax
{
    /**
     * Returns information about templates for a given project.
     *
     * @param int $id Identifier of treated project entity.
     *
     * @return Zikula_Response_Ajax
     */
    public function getProjectTemplates()
    {
        $this->throwForbiddenUnless(SecurityUtil::checkPermission($this->name . '::', '::', ACCESS_ADMIN));
        
        $postData = $this->request->request;
        
        $id = (int) $postData->filter('id', 0, FILTER_VALIDATE_INT);
        if ($id == 0) {
            return new Zikula_Response_Ajax_BadData($this->__('Error: invalid input.'));
        }

        // select project entity
        $project = ModUtil::apiFunc($this->name, 'selection', 'getEntity', array('ot' => 'project', 'id' => $id));
        if ($project == null) {
            return new Zikula_Response_Ajax_NotFound($this->__('No such item.'));
        }

        $result = array();

        foreach ($project['templates'] as $template) {
            $result[] = array(
                'id' => $template->getId(),
                'name' => $template->getTitleFromDisplayPattern(),
                'parameters' => $template->getParameters()
            );
        }
        
        // return the response
        return new Zikula_Response_Ajax(array('templates' => $result));
    }

    /**
     * Modifies the state of a module in a site database.
     *
     * @param int    id         Identifier of treated site entity.
     * @param string moduleName Name of module to change.
     * @param int    newState   New module state.
     *
     * @return Zikula_Response_Ajax
     */
    public function modifyModuleActivation()
    {
        $this->throwForbiddenUnless(SecurityUtil::checkPermission($this->name . '::', '::', ACCESS_ADMIN));

        $postData = $this->request->request;

        $moduleName = $postData->filter('moduleName', '', FILTER_SANITIZE_STRING);
        if ($moduleName == '') {
            return new Zikula_Response_Ajax_BadData($this->__('No module name received.'));
        }

        $newState = $postData->filter('newState', -1, FILTER_VALIDATE_INT);
        if ($newState == -1) {
            return new Zikula_Response_Ajax_BadData($this->__('No new state received.'));
        }

        $id = (int) $postData->filter('id', 0, FILTER_VALIDATE_INT);
        if ($id == 0) {
            return new Zikula_Response_Ajax_BadData($this->__('Error: invalid input.'));
        }

        // select site entity
        $site = ModUtil::apiFunc($this->name, 'selection', 'getEntity', array('ot' => 'site', 'id' => $id));
        if ($site == null) {
            return new Zikula_Response_Ajax_NotFound($this->__('No such item.'));
        }

        // helper for extension-related operations
        $extensionHelper = new Multisites_Util_SiteExtensionHandler($this->serviceManager);

        // apply the state change
        if (!$extensionHelper->modifyModuleActivation($site, array('moduleName' => $moduleName, 'newState' => $newState))) {
            return new Zikula_Response_Ajax_Fatal($this->__('Error changing module state.'));
        }

        // select site modules
        $siteModules = $extensionHelper->getAllModulesFromSiteDb($site);

        // retrieve updated action icons
        $available = array_key_exists($moduleName, $siteModules);
        $icons = $extensionHelper->getActionIconsForSiteModule($this->view, $site, array(
                'name' => $moduleName,
                'available' => $available,
                'siteModules' => $siteModules));

        // return the response
        return new Zikula_Response_Ajax(array('content' => $icons,
                                              'moduleName' => $moduleName));
    }

    /**
     * Creates, changes or deletes a module state in a site database depending on the module initial state.
     *
     * @param int    id         Identifier of treated site entity.
     * @param string moduleName Name of module to change.
     *
     * @return Zikula_Response_Ajax
     */
    public function allowModule()
    {
        $this->throwForbiddenUnless(SecurityUtil::checkPermission($this->name . '::', '::', ACCESS_ADMIN));

        $postData = $this->request->request;

        $moduleName = $postData->filter('moduleName', '', FILTER_SANITIZE_STRING);
        if ($moduleName == '') {
            return new Zikula_Response_Ajax_BadData($this->__('No module name received.'));
        }

        $id = (int) $postData->filter('id', 0, FILTER_VALIDATE_INT);
        if ($id == 0) {
            return new Zikula_Response_Ajax_BadData($this->__('Error: invalid input.'));
        }

        // select site entity
        $site = ModUtil::apiFunc($this->name, 'selection', 'getEntity', array('ot' => 'site', 'id' => $id));
        if ($site == null) {
            return new Zikula_Response_Ajax_NotFound($this->__('No such item.'));
        }

        // helper for extension-related operations
        $extensionHelper = new Multisites_Util_SiteExtensionHandler($this->serviceManager);

        // select site module
        $module = $extensionHelper->getModuleFromSiteDb($site, $moduleName);

        // apply the state change
        if ($module['state'] == ModUtil::STATE_NOTALLOWED) {
            // set the module as deactivated
            if (!$extensionHelper->modifyModuleActivation($site, array('moduleName' => $moduleName, 'newState' => ModUtil::STATE_INACTIVE))) {
                return new Zikula_Response_Ajax_Fatal($this->__('Error changing module state.'));
            }
        } elseif (in_array($module['state'], array(ModUtil::STATE_INACTIVE, ModUtil::STATE_ACTIVE))) {
            // set the module as not allowed
            if (!$extensionHelper->modifyModuleActivation($site, array('moduleName' => $moduleName, 'newState' => ModUtil::STATE_NOTALLOWED))) {
                return new Zikula_Response_Ajax_Fatal($this->__('Error changing module state.'));
            }
        } elseif ($module['state'] == '') {
            // create module
            if (!$extensionHelper->createSiteModule($site, $moduleName)) {
                return new Zikula_Response_Ajax_Fatal($this->__('Error creating module.'));
            }
        } else {
            // get site module
            if (!$extensionHelper->deleteSiteModule($site, $moduleName)) {
                return new Zikula_Response_Ajax_Fatal($this->__('Error deleting module.'));
            }
        }

        // select site modules
        $siteModules = $extensionHelper->getAllModulesFromSiteDb($site);

        // retrieve updated action icons
        $available = array_key_exists($moduleName, $siteModules);
        $icons = $extensionHelper->getActionIconsForSiteModule(null, $site, array(
                'name' => $moduleName,
                'available' => $available,
                'siteModules' => $siteModules));

        // return the response
        return new Zikula_Response_Ajax(array('content' => $icons,
                                              'moduleName' => $moduleName));
    }

    /**
     * Creates or deletes a theme state in a site database depending on the theme initial state.
     *
     * @param int    id        Identifier of treated site entity.
     * @param string themeName Name of theme to change.
     *
     * @return Zikula_Response_Ajax
     */
    public function allowTheme()
    {
        $this->throwForbiddenUnless(SecurityUtil::checkPermission($this->name . '::', '::', ACCESS_ADMIN));

        $postData = $this->request->request;

        $themeName = $postData->filter('themeName', '', FILTER_SANITIZE_STRING);
        if ($themeName == '') {
            return new Zikula_Response_Ajax_BadData($this->__('No theme name received.'));
        }

        $id = (int) $postData->filter('id', 0, FILTER_VALIDATE_INT);
        if ($id == 0) {
            return new Zikula_Response_Ajax_BadData($this->__('Error: invalid input.'));
        }

        // select site entity
        $site = ModUtil::apiFunc($this->name, 'selection', 'getEntity', array('ot' => 'site', 'id' => $id));
        if ($site == null) {
            return new Zikula_Response_Ajax_NotFound($this->__('No such item.'));
        }

        // helper for extension-related operations
        $extensionHelper = new Multisites_Util_SiteExtensionHandler($this->serviceManager);

        // select site theme
        $theme = $extensionHelper->getThemeFromSiteDb($site, $themeName);

        // apply the state change
        if ($theme['name'] == '') {
            // create theme
            if (!$extensionHelper->createSiteTheme($site, $themeName)) {
                return new Zikula_Response_Ajax_Fatal($this->__('Error creating theme.'));
            }
        } else {
            // delete theme
            if (!$extensionHelper->deleteSiteTheme($site, $themeName)) {
                return new Zikula_Response_Ajax_Fatal($this->__('Error deleting theme.'));
            }
        }

        // select site themes
        $siteThemes = $extensionHelper->getAllThemesFromSiteDb($site);

        // retrieve updated action icons
        $available = array_key_exists($themeName, $siteThemes);
        $icons = $extensionHelper->getActionIconsForSiteTheme(null, $site, array(
                'name' => $themeName,
                'available' => $available,
                'siteThemes' => $siteThemes));

        // return the response
        return new Zikula_Response_Ajax(array('content' => $icons,
                                              'themeName' => $themeName));
    }
}
