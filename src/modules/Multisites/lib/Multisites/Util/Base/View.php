<?php
/**
 * Multisites.
 *
 * @copyright Albert Pérez Monfort (Zikula)
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @package Multisites
 * @author Albert Pérez Monfort <aperezm@xtec.cat>.
 * @link http://modulestudio.de
 * @link http://zikula.org
 * @version Generated by ModuleStudio 0.7.0 (http://modulestudio.de).
 */

/**
 * Utility base class for view helper methods.
 */
class Multisites_Util_Base_View extends Zikula_AbstractBase
{
    /**
     * Determines the view template for a certain method with given parameters.
     *
     * @param Zikula_View $view    Reference to view object.
     * @param string      $type    Current controller (name of currently treated entity).
     * @param string      $func    Current function (main, view, ...).
     * @param array       $args    Additional arguments.
     *
     * @return string name of template file.
     */
    public function getViewTemplate(Zikula_View $view, $type, $func, $args = array())
    {
        // create the base template name
        $template = DataUtil::formatForOS($type . '/' . $func);
    
        // check for template extension
        $templateExtension = $this->determineExtension($view, $type, $func, $args);
    
        // check whether a special template is used
        $tpl = (isset($args['tpl']) && !empty($args['tpl'])) ? $args['tpl'] : FormUtil::getPassedValue('tpl', '', 'GETPOST', FILTER_SANITIZE_STRING);
    
        $templateExtension = '.' . $templateExtension;
        if ($templateExtension != '.tpl') {
            $templateExtension .= '.tpl';
        }
    
        if (!empty($tpl) && $view->template_exists($template . '_' . DataUtil::formatForOS($tpl) . $templateExtension)) {
            $template .= '_' . DataUtil::formatForOS($tpl);
        }
        $template .= $templateExtension;
    
        return $template;
    }

    /**
     * Utility method for managing view templates.
     *
     * @param Zikula_View $view     Reference to view object.
     * @param string      $type     Current controller (name of currently treated entity).
     * @param string      $func     Current function (main, view, ...).
     * @param string      $template Optional assignment of precalculated template file.
     * @param array       $args     Additional arguments.
     *
     * @return mixed Output.
     */
    public function processTemplate(Zikula_View $view, $type, $func, $args = array(), $template = '')
    {
        $templateExtension = $this->determineExtension($view, $type, $func, $args);
        if (empty($template)) {
            $template = $this->getViewTemplate($view, $type, $func, $args);
        }
    
        // look whether we need output with or without the theme
        $raw = (bool) (isset($args['raw']) && !empty($args['raw'])) ? $args['raw'] : FormUtil::getPassedValue('raw', false, 'GETPOST', FILTER_VALIDATE_BOOLEAN);
        if (!$raw && $templateExtension != 'tpl') {
            $raw = true;
        }
    
        // ensure the Admin module's plugins are loaded if we have lct=admin but another type value
        $lct = (isset($args['lct']) && !empty($args['lct'])) ? $args['lct'] : FormUtil::getPassedValue('lct', 'user', 'GETPOST', FILTER_SANITIZE_STRING);
        if ($lct == 'admin') {
            // load Smarty plugins of Admin module
            $view->addPluginDir('system/Admin/templates/plugins');
        }
    
        if ($raw == true) {
            // standalone output
            if ($templateExtension == 'pdf') {
                $template = str_replace('.pdf', '', $template);
                return $this->processPdf($view, $template);
            } else {
                $view->display($template);
            }
            System::shutDown();
        }
    
        // normal output
        return $view->fetch($template);
    }

    /**
     * Get extension of the currently treated template.
     *
     * @param Zikula_View $view    Reference to view object.
     * @param string      $type    Current controller (name of currently treated entity).
     * @param string      $func    Current function (main, view, ...).
     * @param array       $args    Additional arguments.
     *
     * @return array List of allowed template extensions.
     */
    protected function determineExtension(Zikula_View $view, $type, $func, $args = array())
    {
        $templateExtension = 'tpl';
        if (!in_array($func, array('view', 'display'))) {
            return $templateExtension;
        }
    
        $extensions = $this->availableExtensions($type, $func);
        foreach ($extensions as $extension) {
            $extensionVar = 'use' . $extension . 'ext';
            $extensionCheck = (isset($args[$extensionVar]) && !empty($extensionVar)) ? $extensionVar : 0;
            if ($extensionCheck != 1) {
                $extensionCheck = (int)FormUtil::getPassedValue($extensionVar, 0, 'GET', FILTER_VALIDATE_INT);
            }
            if ($extensionCheck == 1) {
                $templateExtension = $extension;
                break;
            }
        }
    
        return $templateExtension;
    }

    /**
     * Get list of available template extensions.
     *
     * @param string $type Current controller (name of currently treated entity).
     * @param string $func Current function (main, view, ...).
     *
     * @return array List of allowed template extensions.
     */
    public function availableExtensions($type, $func)
    {
        $extensions = array();
        $hasAdminAccess = SecurityUtil::checkPermission('Multisites:' . ucfirst($type) . ':', '::', ACCESS_ADMIN);
        if ($func == 'view') {
            if ($hasAdminAccess) {
                $extensions = array('csv', 'xml', 'json');
            } else {
                $extensions = array();
            }
        } elseif ($func == 'display') {
            if ($hasAdminAccess) {
                $extensions = array('xml', 'json');
            } else {
                $extensions = array();
            }
        }
    
        return $extensions;
    }

    /**
     * Processes a template file using dompdf (LGPL).
     *
     * @param Zikula_View $view     Reference to view object.
     * @param string      $template Name of template to use.
     *
     * @return mixed Output.
     */
    protected function processPdf(Zikula_View $view, $template)
    {
        // first the content, to set page vars
        $output = $view->fetch($template);
    
        // make local images absolute
        $output = str_replace('img src="/', 'img src="' . System::serverGetVar('DOCUMENT_ROOT') . '/', $output);
    
        // see http://codeigniter.com/forums/viewthread/69388/P15/#561214
        //$output = utf8_decode($output);
    
        // then the surrounding
        $output = $view->fetch('include_pdfheader.tpl') . $output . '</body></html>';
    
        $controllerHelper = new Multisites_Util_Controller($this->serviceManager);
        // create name of the pdf output file
        $fileTitle = $controllerHelper->formatPermalink(System::getVar('sitename'))
                   . '-'
                   . $controllerHelper->formatPermalink(PageUtil::getVar('title'))
                   . '-' . date('Ymd') . '.pdf';
    
        // if ($_GET['dbg'] == 1) die($output);
    
        // instantiate pdf object
        $pdf = new \DOMPDF();
        // define page properties
        $pdf->set_paper('A4');
        // load html input data
        $pdf->load_html($output);
        // create the actual pdf file
        $pdf->render();
        // stream output to browser
        $pdf->stream($fileTitle);
    
        // prevent additional output by shutting down the system
        System::shutDown();
    
        return true;
    }

    /**
     * Display a given file size in a readable format
     *
     * @param string  $size     File size in bytes.
     * @param boolean $nodesc   If set to true the description will not be appended.
     * @param boolean $onlydesc If set to true only the description will be returned.
     *
     * @return string File size in a readable form.
     */
    public function getReadableFileSize($size, $nodesc = false, $onlydesc = false)
    {
        $sizeDesc = $this->__('Bytes');
        if ($size >= 1024) {
            $size /= 1024;
            $sizeDesc = $this->__('KB');
        }
        if ($size >= 1024) {
            $size /= 1024;
            $sizeDesc = $this->__('MB');
        }
        if ($size >= 1024) {
            $size /= 1024;
            $sizeDesc = $this->__('GB');
        }
        $sizeDesc = '&nbsp;' . $sizeDesc;
    
        // format number
        $dec_point = ',';
        $thousands_separator = '.';
        if ($size - number_format($size, 0) >= 0.005) {
            $size = number_format($size, 2, $dec_point, $thousands_separator);
        } else {
            $size = number_format($size, 0, '', $thousands_separator);
        }
    
        // append size descriptor if desired
        if (!$nodesc) {
            $size .= $sizeDesc;
        }
    
        // return either only the description or the complete string
        $result = ($onlydesc) ? $sizeDesc : $size;
    
        return $result;
    }
}
